(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactBootstrapTable"] = factory(require("react"));
	else
		root["ReactBootstrapTable"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 42);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (false) {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(4)();
}


/***/ }),

/***/ 14:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var TIME_TO_CLOSE_MESSAGE = exports.TIME_TO_CLOSE_MESSAGE = 3000;
var DELAY_FOR_DBCLICK = exports.DELAY_FOR_DBCLICK = 200;
var CLICK_TO_CELL_EDIT = exports.CLICK_TO_CELL_EDIT = 'click';
var DBCLICK_TO_CELL_EDIT = exports.DBCLICK_TO_CELL_EDIT = 'dbclick';

/***/ }),

/***/ 4:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(5);
var invariant = __webpack_require__(6);
var ReactPropTypesSecret = __webpack_require__(7);

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ 42:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _wrapper = __webpack_require__(43);

var _wrapper2 = _interopRequireDefault(_wrapper);

var _editingCell = __webpack_require__(44);

var _editingCell2 = _interopRequireDefault(_editingCell);

var _const = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    wrapperFactory: _wrapper2.default,
    editingCellFactory: _editingCell2.default,
    CLICK_TO_CELL_EDIT: _const.CLICK_TO_CELL_EDIT,
    DBCLICK_TO_CELL_EDIT: _const.DBCLICK_TO_CELL_EDIT,
    DELAY_FOR_DBCLICK: _const.DELAY_FOR_DBCLICK,
    options: options
  };
};

/***/ }),

/***/ 43:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _const = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */


exports.default = function (Base, _ref) {
  var _class, _temp;

  var _ = _ref._,
      remoteResolver = _ref.remoteResolver;

  var EditingCell = void 0;
  return _temp = _class = function (_remoteResolver) {
    _inherits(CellEditWrapper, _remoteResolver);

    function CellEditWrapper(props) {
      _classCallCheck(this, CellEditWrapper);

      var _this = _possibleConstructorReturn(this, (CellEditWrapper.__proto__ || Object.getPrototypeOf(CellEditWrapper)).call(this, props));

      EditingCell = props.cellEdit.editingCellFactory(_);
      _this.startEditing = _this.startEditing.bind(_this);
      _this.escapeEditing = _this.escapeEditing.bind(_this);
      _this.completeEditing = _this.completeEditing.bind(_this);
      _this.handleCellUpdate = _this.handleCellUpdate.bind(_this);
      _this.state = {
        ridx: null,
        cidx: null,
        message: null,
        isDataChanged: false
      };
      return _this;
    }

    _createClass(CellEditWrapper, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (nextProps.cellEdit && this.isRemoteCellEdit()) {
          if (nextProps.cellEdit.options.errorMessage) {
            this.setState(function () {
              return {
                isDataChanged: false,
                message: nextProps.cellEdit.options.errorMessage
              };
            });
          } else {
            this.setState(function () {
              return {
                isDataChanged: true
              };
            });
            this.escapeEditing();
          }
        } else {
          this.setState(function () {
            return {
              isDataChanged: false
            };
          });
        }
      }
    }, {
      key: 'handleCellUpdate',
      value: function handleCellUpdate(row, column, newValue) {
        var _props = this.props,
            keyField = _props.keyField,
            cellEdit = _props.cellEdit,
            store = _props.store;
        var _cellEdit$options = cellEdit.options,
            beforeSaveCell = _cellEdit$options.beforeSaveCell,
            afterSaveCell = _cellEdit$options.afterSaveCell;

        var oldValue = _.get(row, column.dataField);
        var rowId = _.get(row, keyField);
        if (_.isFunction(beforeSaveCell)) beforeSaveCell(oldValue, newValue, row, column);
        if (this.isRemoteCellEdit()) {
          this.handleCellChange(rowId, column.dataField, newValue);
        } else {
          store.edit(rowId, column.dataField, newValue);
          if (_.isFunction(afterSaveCell)) afterSaveCell(oldValue, newValue, row, column);
          this.completeEditing();
        }
      }
    }, {
      key: 'completeEditing',
      value: function completeEditing() {
        this.setState(function () {
          return {
            ridx: null,
            cidx: null,
            message: null,
            isDataChanged: true
          };
        });
      }
    }, {
      key: 'startEditing',
      value: function startEditing(ridx, cidx) {
        var _this2 = this;

        var editing = function editing() {
          _this2.setState(function () {
            return {
              ridx: ridx,
              cidx: cidx,
              isDataChanged: false
            };
          });
        };

        var selectRow = this.props.selectRow;

        if (!selectRow || selectRow.clickToEdit || !selectRow.clickToSelect) editing();
      }
    }, {
      key: 'escapeEditing',
      value: function escapeEditing() {
        this.setState(function () {
          return {
            ridx: null,
            cidx: null
          };
        });
      }
    }, {
      key: 'render',
      value: function render() {
        var _state = this.state,
            isDataChanged = _state.isDataChanged,
            stateRest = _objectWithoutProperties(_state, ['isDataChanged']);

        var _props$cellEdit = this.props.cellEdit,
            _props$cellEdit$optio = _props$cellEdit.options,
            nonEditableRows = _props$cellEdit$optio.nonEditableRows,
            errorMessage = _props$cellEdit$optio.errorMessage,
            optionsRest = _objectWithoutProperties(_props$cellEdit$optio, ['nonEditableRows', 'errorMessage']),
            editingCellFactory = _props$cellEdit.editingCellFactory,
            cellEditRest = _objectWithoutProperties(_props$cellEdit, ['options', 'editingCellFactory']);

        var newCellEdit = _extends({}, optionsRest, cellEditRest, stateRest, {
          EditingCell: EditingCell,
          nonEditableRows: _.isDefined(nonEditableRows) ? nonEditableRows() : [],
          onStart: this.startEditing,
          onEscape: this.escapeEditing,
          onUpdate: this.handleCellUpdate
        });

        return _react2.default.createElement(Base, _extends({}, this.props, {
          data: this.props.store.data,
          isDataChanged: isDataChanged,
          cellEdit: newCellEdit
        }));
      }
    }]);

    return CellEditWrapper;
  }(remoteResolver(_react.Component)), _class.propTypes = {
    options: _propTypes2.default.shape({
      mode: _propTypes2.default.oneOf([_const.CLICK_TO_CELL_EDIT, _const.DBCLICK_TO_CELL_EDIT]).isRequired,
      onErrorMessageDisappear: _propTypes2.default.func,
      blurToSave: _propTypes2.default.bool,
      beforeSaveCell: _propTypes2.default.func,
      afterSaveCell: _propTypes2.default.func,
      nonEditableRows: _propTypes2.default.func,
      timeToCloseMessage: _propTypes2.default.number,
      errorMessage: _propTypes2.default.string
    })
  }, _temp;
};

/***/ }),

/***/ 44:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(8);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _textEditor = __webpack_require__(45);

var _textEditor2 = _interopRequireDefault(_textEditor);

var _editorIndicator = __webpack_require__(46);

var _editorIndicator2 = _interopRequireDefault(_editorIndicator);

var _const = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint react/prop-types: 0 */
/* eslint no-return-assign: 0 */
/* eslint class-methods-use-this: 0 */
/* eslint jsx-a11y/no-noninteractive-element-interactions: 0 */


exports.default = function (_) {
  var _class, _temp;

  return _temp = _class = function (_Component) {
    _inherits(EditingCell, _Component);

    function EditingCell(props) {
      _classCallCheck(this, EditingCell);

      var _this = _possibleConstructorReturn(this, (EditingCell.__proto__ || Object.getPrototypeOf(EditingCell)).call(this, props));

      _this.indicatorTimer = null;
      _this.clearTimer = _this.clearTimer.bind(_this);
      _this.handleBlur = _this.handleBlur.bind(_this);
      _this.handleClick = _this.handleClick.bind(_this);
      _this.handleKeyDown = _this.handleKeyDown.bind(_this);
      _this.beforeComplete = _this.beforeComplete.bind(_this);
      _this.state = {
        invalidMessage: null
      };
      return _this;
    }

    _createClass(EditingCell, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(_ref) {
        var message = _ref.message;

        if (_.isDefined(message)) {
          this.createTimer();
          this.setState(function () {
            return {
              invalidMessage: message
            };
          });
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.clearTimer();
      }
    }, {
      key: 'clearTimer',
      value: function clearTimer() {
        if (this.indicatorTimer) {
          clearTimeout(this.indicatorTimer);
        }
      }
    }, {
      key: 'createTimer',
      value: function createTimer() {
        var _this2 = this;

        this.clearTimer();
        var _props = this.props,
            timeToCloseMessage = _props.timeToCloseMessage,
            onErrorMessageDisappear = _props.onErrorMessageDisappear;

        this.indicatorTimer = _.sleep(function () {
          _this2.setState(function () {
            return {
              invalidMessage: null
            };
          });
          if (_.isFunction(onErrorMessageDisappear)) onErrorMessageDisappear();
        }, timeToCloseMessage);
      }
    }, {
      key: 'beforeComplete',
      value: function beforeComplete(row, column, newValue) {
        var onUpdate = this.props.onUpdate;

        if (_.isFunction(column.validator)) {
          var validateForm = column.validator(newValue, row, column);
          if (_.isObject(validateForm) && !validateForm.valid) {
            this.setState(function () {
              return {
                invalidMessage: validateForm.message
              };
            });
            this.createTimer();
            return;
          }
        }
        onUpdate(row, column, newValue);
      }
    }, {
      key: 'handleBlur',
      value: function handleBlur() {
        var _props2 = this.props,
            onEscape = _props2.onEscape,
            blurToSave = _props2.blurToSave,
            row = _props2.row,
            column = _props2.column;

        if (blurToSave) {
          var value = this.editor.text.value;
          if (!_.isDefined(value)) {
            // TODO: for other custom or embed editor
          }
          this.beforeComplete(row, column, value);
        } else {
          onEscape();
        }
      }
    }, {
      key: 'handleKeyDown',
      value: function handleKeyDown(e) {
        var _props3 = this.props,
            onEscape = _props3.onEscape,
            row = _props3.row,
            column = _props3.column;

        if (e.keyCode === 27) {
          // ESC
          onEscape();
        } else if (e.keyCode === 13) {
          // ENTER
          var value = e.currentTarget.value;
          if (!_.isDefined(value)) {
            // TODO: for other custom or embed editor
          }
          this.beforeComplete(row, column, value);
        }
      }
    }, {
      key: 'handleClick',
      value: function handleClick(e) {
        if (e.target.tagName !== 'TD') {
          // To avoid the row selection event be triggered,
          // When user define selectRow.clickToSelect and selectRow.clickToEdit
          // We shouldn't trigger selection event even if user click on the cell editor(input)
          e.stopPropagation();
        }
      }
    }, {
      key: 'render',
      value: function render() {
        var _this3 = this;

        var invalidMessage = this.state.invalidMessage;
        var _props4 = this.props,
            row = _props4.row,
            column = _props4.column,
            className = _props4.className,
            style = _props4.style,
            rowIndex = _props4.rowIndex,
            columnIndex = _props4.columnIndex;
        var dataField = column.dataField;


        var value = _.get(row, dataField);
        var editorAttrs = {
          onKeyDown: this.handleKeyDown,
          onBlur: this.handleBlur
        };

        var hasError = _.isDefined(invalidMessage);
        var customEditorClass = column.editorClasses || '';
        if (_.isFunction(column.editorClasses)) {
          customEditorClass = column.editorClasses(value, row, rowIndex, columnIndex);
        }

        var editorStyle = column.editorStyle || {};
        if (_.isFunction(column.editorStyle)) {
          editorStyle = column.editorStyle(value, row, rowIndex, columnIndex);
        }

        var editorClass = (0, _classnames2.default)({
          animated: hasError,
          shake: hasError
        }, customEditorClass);

        return _react2.default.createElement(
          'td',
          {
            className: (0, _classnames2.default)('react-bootstrap-table-editing-cell', className),
            style: style,
            onClick: this.handleClick
          },
          _react2.default.createElement(_textEditor2.default, _extends({
            ref: function ref(node) {
              return _this3.editor = node;
            },
            defaultValue: value,
            style: editorStyle,
            className: editorClass
          }, editorAttrs)),
          hasError ? _react2.default.createElement(_editorIndicator2.default, { invalidMessage: invalidMessage }) : null
        );
      }
    }]);

    return EditingCell;
  }(_react.Component), _class.propTypes = {
    row: _propTypes2.default.object.isRequired,
    rowIndex: _propTypes2.default.number.isRequired,
    column: _propTypes2.default.object.isRequired,
    columnIndex: _propTypes2.default.number.isRequired,
    onUpdate: _propTypes2.default.func.isRequired,
    onEscape: _propTypes2.default.func.isRequired,
    timeToCloseMessage: _propTypes2.default.number,
    className: _propTypes2.default.string,
    style: _propTypes2.default.object
  }, _class.defaultProps = {
    timeToCloseMessage: _const.TIME_TO_CLOSE_MESSAGE,
    className: null,
    style: {}
  }, _temp;
};

/***/ }),

/***/ 45:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _classnames = __webpack_require__(8);

var _classnames2 = _interopRequireDefault(_classnames);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-return-assign: 0 */


var TextEditor = function (_Component) {
  _inherits(TextEditor, _Component);

  function TextEditor() {
    _classCallCheck(this, TextEditor);

    return _possibleConstructorReturn(this, (TextEditor.__proto__ || Object.getPrototypeOf(TextEditor)).apply(this, arguments));
  }

  _createClass(TextEditor, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var defaultValue = this.props.defaultValue;

      this.text.value = defaultValue;
      this.text.focus();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var _props = this.props,
          defaultValue = _props.defaultValue,
          className = _props.className,
          rest = _objectWithoutProperties(_props, ['defaultValue', 'className']);

      var editorClass = (0, _classnames2.default)('form-control editor edit-text', className);
      return _react2.default.createElement('input', _extends({
        ref: function ref(node) {
          return _this2.text = node;
        },
        type: 'text',
        className: editorClass
      }, rest));
    }
  }]);

  return TextEditor;
}(_react.Component);

TextEditor.propTypes = {
  className: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
  defaultValue: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.number])
};
TextEditor.defaultProps = {
  className: null,
  defaultValue: ''
};
exports.default = TextEditor;

/***/ }),

/***/ 46:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(1);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-return-assign: 0 */
var EditorIndicator = function EditorIndicator(_ref) {
  var invalidMessage = _ref.invalidMessage;
  return _react2.default.createElement(
    'div',
    { className: 'alert alert-danger fade in' },
    _react2.default.createElement(
      'strong',
      null,
      invalidMessage
    )
  );
};

EditorIndicator.propTypes = {
  invalidMessage: _propTypes2.default.string
};

EditorIndicator.defaultProps = {
  invalidMessage: null
};
exports.default = EditorIndicator;

/***/ }),

/***/ 5:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (false) {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;

/***/ }),

/***/ 7:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ 8:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return classNames;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
		window.classNames = classNames;
	}
}());


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyZDQyMjU0ZWM5ODljNDJjY2EyMiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwiUmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImNvbW1vbmpzXCI6XCJyZWFjdFwiLFwiYW1kXCI6XCJyZWFjdFwifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWVkaXRvci9zcmMvY29uc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy93cmFwcGVyLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy9lZGl0aW5nLWNlbGwuanMiLCJ3ZWJwYWNrOi8vLy4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1lZGl0b3Ivc3JjL3RleHQtZWRpdG9yLmpzIiwid2VicGFjazovLy8uL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy9lZGl0b3ItaW5kaWNhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIl0sIm5hbWVzIjpbIlRJTUVfVE9fQ0xPU0VfTUVTU0FHRSIsIkRFTEFZX0ZPUl9EQkNMSUNLIiwiQ0xJQ0tfVE9fQ0VMTF9FRElUIiwiREJDTElDS19UT19DRUxMX0VESVQiLCJvcHRpb25zIiwid3JhcHBlckZhY3RvcnkiLCJlZGl0aW5nQ2VsbEZhY3RvcnkiLCJCYXNlIiwiXyIsInJlbW90ZVJlc29sdmVyIiwiRWRpdGluZ0NlbGwiLCJwcm9wcyIsImNlbGxFZGl0Iiwic3RhcnRFZGl0aW5nIiwiYmluZCIsImVzY2FwZUVkaXRpbmciLCJjb21wbGV0ZUVkaXRpbmciLCJoYW5kbGVDZWxsVXBkYXRlIiwic3RhdGUiLCJyaWR4IiwiY2lkeCIsIm1lc3NhZ2UiLCJpc0RhdGFDaGFuZ2VkIiwibmV4dFByb3BzIiwiaXNSZW1vdGVDZWxsRWRpdCIsImVycm9yTWVzc2FnZSIsInNldFN0YXRlIiwicm93IiwiY29sdW1uIiwibmV3VmFsdWUiLCJrZXlGaWVsZCIsInN0b3JlIiwiYmVmb3JlU2F2ZUNlbGwiLCJhZnRlclNhdmVDZWxsIiwib2xkVmFsdWUiLCJnZXQiLCJkYXRhRmllbGQiLCJyb3dJZCIsImlzRnVuY3Rpb24iLCJoYW5kbGVDZWxsQ2hhbmdlIiwiZWRpdCIsImVkaXRpbmciLCJzZWxlY3RSb3ciLCJjbGlja1RvRWRpdCIsImNsaWNrVG9TZWxlY3QiLCJzdGF0ZVJlc3QiLCJub25FZGl0YWJsZVJvd3MiLCJvcHRpb25zUmVzdCIsImNlbGxFZGl0UmVzdCIsIm5ld0NlbGxFZGl0IiwiaXNEZWZpbmVkIiwib25TdGFydCIsIm9uRXNjYXBlIiwib25VcGRhdGUiLCJkYXRhIiwicHJvcFR5cGVzIiwic2hhcGUiLCJtb2RlIiwib25lT2YiLCJpc1JlcXVpcmVkIiwib25FcnJvck1lc3NhZ2VEaXNhcHBlYXIiLCJmdW5jIiwiYmx1clRvU2F2ZSIsImJvb2wiLCJ0aW1lVG9DbG9zZU1lc3NhZ2UiLCJudW1iZXIiLCJzdHJpbmciLCJpbmRpY2F0b3JUaW1lciIsImNsZWFyVGltZXIiLCJoYW5kbGVCbHVyIiwiaGFuZGxlQ2xpY2siLCJoYW5kbGVLZXlEb3duIiwiYmVmb3JlQ29tcGxldGUiLCJpbnZhbGlkTWVzc2FnZSIsImNyZWF0ZVRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwic2xlZXAiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0ZUZvcm0iLCJpc09iamVjdCIsInZhbGlkIiwidmFsdWUiLCJlZGl0b3IiLCJ0ZXh0IiwiZSIsImtleUNvZGUiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwidGFnTmFtZSIsInN0b3BQcm9wYWdhdGlvbiIsImNsYXNzTmFtZSIsInN0eWxlIiwicm93SW5kZXgiLCJjb2x1bW5JbmRleCIsImVkaXRvckF0dHJzIiwib25LZXlEb3duIiwib25CbHVyIiwiaGFzRXJyb3IiLCJjdXN0b21FZGl0b3JDbGFzcyIsImVkaXRvckNsYXNzZXMiLCJlZGl0b3JTdHlsZSIsImVkaXRvckNsYXNzIiwiYW5pbWF0ZWQiLCJzaGFrZSIsIm5vZGUiLCJvYmplY3QiLCJkZWZhdWx0UHJvcHMiLCJUZXh0RWRpdG9yIiwiZGVmYXVsdFZhbHVlIiwiZm9jdXMiLCJyZXN0Iiwib25lT2ZUeXBlIiwiRWRpdG9ySW5kaWNhdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJB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Q0E7QUFDQSxxREFBcUQ7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSwyQjs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7O0FBRUEsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFBQTtBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiJyZWFjdC1ib290c3RyYXAtdGFibGUyLWVkaXRvci9kaXN0L3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiUmVhY3RCb290c3RyYXBUYWJsZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSZWFjdEJvb3RzdHJhcFRhYmxlXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNDIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDJkNDIyNTRlYzk4OWM0MmNjYTIyIiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9XG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDIgMyA0IDUgNiA3IDggOSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDQgNSA2IDcgOCA5IiwiZXhwb3J0IGNvbnN0IFRJTUVfVE9fQ0xPU0VfTUVTU0FHRSA9IDMwMDA7XG5leHBvcnQgY29uc3QgREVMQVlfRk9SX0RCQ0xJQ0sgPSAyMDA7XG5leHBvcnQgY29uc3QgQ0xJQ0tfVE9fQ0VMTF9FRElUID0gJ2NsaWNrJztcbmV4cG9ydCBjb25zdCBEQkNMSUNLX1RPX0NFTExfRURJVCA9ICdkYmNsaWNrJztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy9jb25zdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIDQgNSA2IDcgOCA5IiwiaW1wb3J0IHdyYXBwZXJGYWN0b3J5IGZyb20gJy4vc3JjL3dyYXBwZXInO1xuaW1wb3J0IGVkaXRpbmdDZWxsRmFjdG9yeSBmcm9tICcuL3NyYy9lZGl0aW5nLWNlbGwnO1xuaW1wb3J0IHtcbiAgQ0xJQ0tfVE9fQ0VMTF9FRElULFxuICBEQkNMSUNLX1RPX0NFTExfRURJVCxcbiAgREVMQVlfRk9SX0RCQ0xJQ0tcbn0gZnJvbSAnLi9zcmMvY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCAob3B0aW9ucyA9IHt9KSA9PiAoe1xuICB3cmFwcGVyRmFjdG9yeSxcbiAgZWRpdGluZ0NlbGxGYWN0b3J5LFxuICBDTElDS19UT19DRUxMX0VESVQsXG4gIERCQ0xJQ0tfVE9fQ0VMTF9FRElULFxuICBERUxBWV9GT1JfREJDTElDSyxcbiAgb3B0aW9uc1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wYWNrYWdlcy9yZWFjdC1ib290c3RyYXAtdGFibGUyLWVkaXRvci9pbmRleC5qcyIsIi8qIGVzbGludCByZWFjdC9wcm9wLXR5cGVzOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IHsgQ0xJQ0tfVE9fQ0VMTF9FRElULCBEQkNMSUNLX1RPX0NFTExfRURJVCB9IGZyb20gJy4vY29uc3QnO1xuXG5leHBvcnQgZGVmYXVsdCAoXG4gIEJhc2UsXG4gIHsgXywgcmVtb3RlUmVzb2x2ZXIgfVxuKSA9PiB7XG4gIGxldCBFZGl0aW5nQ2VsbDtcbiAgcmV0dXJuIGNsYXNzIENlbGxFZGl0V3JhcHBlciBleHRlbmRzIHJlbW90ZVJlc29sdmVyKENvbXBvbmVudCkge1xuICAgIHN0YXRpYyBwcm9wVHlwZXMgPSB7XG4gICAgICBvcHRpb25zOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgICBtb2RlOiBQcm9wVHlwZXMub25lT2YoW0NMSUNLX1RPX0NFTExfRURJVCwgREJDTElDS19UT19DRUxMX0VESVRdKS5pc1JlcXVpcmVkLFxuICAgICAgICBvbkVycm9yTWVzc2FnZURpc2FwcGVhcjogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGJsdXJUb1NhdmU6IFByb3BUeXBlcy5ib29sLFxuICAgICAgICBiZWZvcmVTYXZlQ2VsbDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgICAgIGFmdGVyU2F2ZUNlbGw6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICBub25FZGl0YWJsZVJvd3M6IFByb3BUeXBlcy5mdW5jLFxuICAgICAgICB0aW1lVG9DbG9zZU1lc3NhZ2U6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIGVycm9yTWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgRWRpdGluZ0NlbGwgPSBwcm9wcy5jZWxsRWRpdC5lZGl0aW5nQ2VsbEZhY3RvcnkoXyk7XG4gICAgICB0aGlzLnN0YXJ0RWRpdGluZyA9IHRoaXMuc3RhcnRFZGl0aW5nLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmVzY2FwZUVkaXRpbmcgPSB0aGlzLmVzY2FwZUVkaXRpbmcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY29tcGxldGVFZGl0aW5nID0gdGhpcy5jb21wbGV0ZUVkaXRpbmcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuaGFuZGxlQ2VsbFVwZGF0ZSA9IHRoaXMuaGFuZGxlQ2VsbFVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgcmlkeDogbnVsbCxcbiAgICAgICAgY2lkeDogbnVsbCxcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgaXNEYXRhQ2hhbmdlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuY2VsbEVkaXQgJiYgdGhpcy5pc1JlbW90ZUNlbGxFZGl0KCkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wcy5jZWxsRWRpdC5vcHRpb25zLmVycm9yTWVzc2FnZSkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgICAgIGlzRGF0YUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogbmV4dFByb3BzLmNlbGxFZGl0Lm9wdGlvbnMuZXJyb3JNZXNzYWdlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgICAgIGlzRGF0YUNoYW5nZWQ6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5lc2NhcGVFZGl0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgICBpc0RhdGFDaGFuZ2VkOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlQ2VsbFVwZGF0ZShyb3csIGNvbHVtbiwgbmV3VmFsdWUpIHtcbiAgICAgIGNvbnN0IHsga2V5RmllbGQsIGNlbGxFZGl0LCBzdG9yZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IHsgYmVmb3JlU2F2ZUNlbGwsIGFmdGVyU2F2ZUNlbGwgfSA9IGNlbGxFZGl0Lm9wdGlvbnM7XG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IF8uZ2V0KHJvdywgY29sdW1uLmRhdGFGaWVsZCk7XG4gICAgICBjb25zdCByb3dJZCA9IF8uZ2V0KHJvdywga2V5RmllbGQpO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihiZWZvcmVTYXZlQ2VsbCkpIGJlZm9yZVNhdmVDZWxsKG9sZFZhbHVlLCBuZXdWYWx1ZSwgcm93LCBjb2x1bW4pO1xuICAgICAgaWYgKHRoaXMuaXNSZW1vdGVDZWxsRWRpdCgpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlQ2VsbENoYW5nZShyb3dJZCwgY29sdW1uLmRhdGFGaWVsZCwgbmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuZWRpdChyb3dJZCwgY29sdW1uLmRhdGFGaWVsZCwgbmV3VmFsdWUpO1xuICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGFmdGVyU2F2ZUNlbGwpKSBhZnRlclNhdmVDZWxsKG9sZFZhbHVlLCBuZXdWYWx1ZSwgcm93LCBjb2x1bW4pO1xuICAgICAgICB0aGlzLmNvbXBsZXRlRWRpdGluZygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlRWRpdGluZygpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgcmlkeDogbnVsbCxcbiAgICAgICAgY2lkeDogbnVsbCxcbiAgICAgICAgbWVzc2FnZTogbnVsbCxcbiAgICAgICAgaXNEYXRhQ2hhbmdlZDogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHN0YXJ0RWRpdGluZyhyaWR4LCBjaWR4KSB7XG4gICAgICBjb25zdCBlZGl0aW5nID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7XG4gICAgICAgICAgcmlkeCxcbiAgICAgICAgICBjaWR4LFxuICAgICAgICAgIGlzRGF0YUNoYW5nZWQ6IGZhbHNlXG4gICAgICAgIH0pKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgc2VsZWN0Um93IH0gPSB0aGlzLnByb3BzO1xuICAgICAgaWYgKCFzZWxlY3RSb3cgfHwgKHNlbGVjdFJvdy5jbGlja1RvRWRpdCB8fCAhc2VsZWN0Um93LmNsaWNrVG9TZWxlY3QpKSBlZGl0aW5nKCk7XG4gICAgfVxuXG4gICAgZXNjYXBlRWRpdGluZygpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoKCkgPT4gKHtcbiAgICAgICAgcmlkeDogbnVsbCxcbiAgICAgICAgY2lkeDogbnVsbFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgIGNvbnN0IHsgaXNEYXRhQ2hhbmdlZCwgLi4uc3RhdGVSZXN0IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsRWRpdDoge1xuICAgICAgICAgIG9wdGlvbnM6IHsgbm9uRWRpdGFibGVSb3dzLCBlcnJvck1lc3NhZ2UsIC4uLm9wdGlvbnNSZXN0IH0sXG4gICAgICAgICAgZWRpdGluZ0NlbGxGYWN0b3J5LFxuICAgICAgICAgIC4uLmNlbGxFZGl0UmVzdFxuICAgICAgICB9XG4gICAgICB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGNvbnN0IG5ld0NlbGxFZGl0ID0ge1xuICAgICAgICAuLi5vcHRpb25zUmVzdCxcbiAgICAgICAgLi4uY2VsbEVkaXRSZXN0LFxuICAgICAgICAuLi5zdGF0ZVJlc3QsXG4gICAgICAgIEVkaXRpbmdDZWxsLFxuICAgICAgICBub25FZGl0YWJsZVJvd3M6IF8uaXNEZWZpbmVkKG5vbkVkaXRhYmxlUm93cykgPyBub25FZGl0YWJsZVJvd3MoKSA6IFtdLFxuICAgICAgICBvblN0YXJ0OiB0aGlzLnN0YXJ0RWRpdGluZyxcbiAgICAgICAgb25Fc2NhcGU6IHRoaXMuZXNjYXBlRWRpdGluZyxcbiAgICAgICAgb25VcGRhdGU6IHRoaXMuaGFuZGxlQ2VsbFVwZGF0ZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJhc2VcbiAgICAgICAgICB7IC4uLnRoaXMucHJvcHMgfVxuICAgICAgICAgIGRhdGE9eyB0aGlzLnByb3BzLnN0b3JlLmRhdGEgfVxuICAgICAgICAgIGlzRGF0YUNoYW5nZWQ9eyBpc0RhdGFDaGFuZ2VkIH1cbiAgICAgICAgICBjZWxsRWRpdD17IG5ld0NlbGxFZGl0IH1cbiAgICAgICAgLz5cbiAgICAgICk7XG4gICAgfVxuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy93cmFwcGVyLmpzIiwiLyogZXNsaW50IHJlYWN0L3Byb3AtdHlwZXM6IDAgKi9cbi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG4vKiBlc2xpbnQgY2xhc3MtbWV0aG9kcy11c2UtdGhpczogMCAqL1xuLyogZXNsaW50IGpzeC1hMTF5L25vLW5vbmludGVyYWN0aXZlLWVsZW1lbnQtaW50ZXJhY3Rpb25zOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IFRleHRFZGl0b3IgZnJvbSAnLi90ZXh0LWVkaXRvcic7XG5pbXBvcnQgRWRpdG9ySW5kaWNhdG9yIGZyb20gJy4vZWRpdG9yLWluZGljYXRvcic7XG5pbXBvcnQgeyBUSU1FX1RPX0NMT1NFX01FU1NBR0UgfSBmcm9tICcuL2NvbnN0JztcblxuZXhwb3J0IGRlZmF1bHQgXyA9PlxuICBjbGFzcyBFZGl0aW5nQ2VsbCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAgIHJvdzogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgcm93SW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgIGNvbHVtbjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgICAgY29sdW1uSW5kZXg6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcbiAgICAgIG9uVXBkYXRlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgb25Fc2NhcGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICB0aW1lVG9DbG9zZU1lc3NhZ2U6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdFxuICAgIH1cblxuICAgIHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG4gICAgICB0aW1lVG9DbG9zZU1lc3NhZ2U6IFRJTUVfVE9fQ0xPU0VfTUVTU0FHRSxcbiAgICAgIGNsYXNzTmFtZTogbnVsbCxcbiAgICAgIHN0eWxlOiB7fVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICBzdXBlcihwcm9wcyk7XG4gICAgICB0aGlzLmluZGljYXRvclRpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuY2xlYXJUaW1lciA9IHRoaXMuY2xlYXJUaW1lci5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5oYW5kbGVCbHVyID0gdGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmhhbmRsZUNsaWNrID0gdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJlZm9yZUNvbXBsZXRlID0gdGhpcy5iZWZvcmVDb21wbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgaW52YWxpZE1lc3NhZ2U6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh7IG1lc3NhZ2UgfSkge1xuICAgICAgaWYgKF8uaXNEZWZpbmVkKG1lc3NhZ2UpKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlVGltZXIoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICAgIGludmFsaWRNZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgIH1cblxuICAgIGNsZWFyVGltZXIoKSB7XG4gICAgICBpZiAodGhpcy5pbmRpY2F0b3JUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pbmRpY2F0b3JUaW1lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlVGltZXIoKSB7XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKTtcbiAgICAgIGNvbnN0IHsgdGltZVRvQ2xvc2VNZXNzYWdlLCBvbkVycm9yTWVzc2FnZURpc2FwcGVhciB9ID0gdGhpcy5wcm9wcztcbiAgICAgIHRoaXMuaW5kaWNhdG9yVGltZXIgPSBfLnNsZWVwKCgpID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSgoKSA9PiAoe1xuICAgICAgICAgIGludmFsaWRNZXNzYWdlOiBudWxsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKF8uaXNGdW5jdGlvbihvbkVycm9yTWVzc2FnZURpc2FwcGVhcikpIG9uRXJyb3JNZXNzYWdlRGlzYXBwZWFyKCk7XG4gICAgICB9LCB0aW1lVG9DbG9zZU1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGJlZm9yZUNvbXBsZXRlKHJvdywgY29sdW1uLCBuZXdWYWx1ZSkge1xuICAgICAgY29uc3QgeyBvblVwZGF0ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29sdW1uLnZhbGlkYXRvcikpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVGb3JtID0gY29sdW1uLnZhbGlkYXRvcihuZXdWYWx1ZSwgcm93LCBjb2x1bW4pO1xuICAgICAgICBpZiAoXy5pc09iamVjdCh2YWxpZGF0ZUZvcm0pICYmICF2YWxpZGF0ZUZvcm0udmFsaWQpIHtcbiAgICAgICAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7XG4gICAgICAgICAgICBpbnZhbGlkTWVzc2FnZTogdmFsaWRhdGVGb3JtLm1lc3NhZ2VcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgdGhpcy5jcmVhdGVUaW1lcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb25VcGRhdGUocm93LCBjb2x1bW4sIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVCbHVyKCkge1xuICAgICAgY29uc3QgeyBvbkVzY2FwZSwgYmx1clRvU2F2ZSwgcm93LCBjb2x1bW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoYmx1clRvU2F2ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZWRpdG9yLnRleHQudmFsdWU7XG4gICAgICAgIGlmICghXy5pc0RlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgLy8gVE9ETzogZm9yIG90aGVyIGN1c3RvbSBvciBlbWJlZCBlZGl0b3JcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlZm9yZUNvbXBsZXRlKHJvdywgY29sdW1uLCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVzY2FwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUtleURvd24oZSkge1xuICAgICAgY29uc3QgeyBvbkVzY2FwZSwgcm93LCBjb2x1bW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoZS5rZXlDb2RlID09PSAyNykgeyAvLyBFU0NcbiAgICAgICAgb25Fc2NhcGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09PSAxMykgeyAvLyBFTlRFUlxuICAgICAgICBjb25zdCB2YWx1ZSA9IGUuY3VycmVudFRhcmdldC52YWx1ZTtcbiAgICAgICAgaWYgKCFfLmlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAvLyBUT0RPOiBmb3Igb3RoZXIgY3VzdG9tIG9yIGVtYmVkIGVkaXRvclxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlQ29tcGxldGUocm93LCBjb2x1bW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVDbGljayhlKSB7XG4gICAgICBpZiAoZS50YXJnZXQudGFnTmFtZSAhPT0gJ1REJykge1xuICAgICAgICAvLyBUbyBhdm9pZCB0aGUgcm93IHNlbGVjdGlvbiBldmVudCBiZSB0cmlnZ2VyZWQsXG4gICAgICAgIC8vIFdoZW4gdXNlciBkZWZpbmUgc2VsZWN0Um93LmNsaWNrVG9TZWxlY3QgYW5kIHNlbGVjdFJvdy5jbGlja1RvRWRpdFxuICAgICAgICAvLyBXZSBzaG91bGRuJ3QgdHJpZ2dlciBzZWxlY3Rpb24gZXZlbnQgZXZlbiBpZiB1c2VyIGNsaWNrIG9uIHRoZSBjZWxsIGVkaXRvcihpbnB1dClcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICBjb25zdCB7IGludmFsaWRNZXNzYWdlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgeyByb3csIGNvbHVtbiwgY2xhc3NOYW1lLCBzdHlsZSwgcm93SW5kZXgsIGNvbHVtbkluZGV4IH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3QgeyBkYXRhRmllbGQgfSA9IGNvbHVtbjtcblxuICAgICAgY29uc3QgdmFsdWUgPSBfLmdldChyb3csIGRhdGFGaWVsZCk7XG4gICAgICBjb25zdCBlZGl0b3JBdHRycyA9IHtcbiAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZUtleURvd24sXG4gICAgICAgIG9uQmx1cjogdGhpcy5oYW5kbGVCbHVyXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBoYXNFcnJvciA9IF8uaXNEZWZpbmVkKGludmFsaWRNZXNzYWdlKTtcbiAgICAgIGxldCBjdXN0b21FZGl0b3JDbGFzcyA9IGNvbHVtbi5lZGl0b3JDbGFzc2VzIHx8ICcnO1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihjb2x1bW4uZWRpdG9yQ2xhc3NlcykpIHtcbiAgICAgICAgY3VzdG9tRWRpdG9yQ2xhc3MgPSBjb2x1bW4uZWRpdG9yQ2xhc3Nlcyh2YWx1ZSwgcm93LCByb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWRpdG9yU3R5bGUgPSBjb2x1bW4uZWRpdG9yU3R5bGUgfHwge307XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbHVtbi5lZGl0b3JTdHlsZSkpIHtcbiAgICAgICAgZWRpdG9yU3R5bGUgPSBjb2x1bW4uZWRpdG9yU3R5bGUodmFsdWUsIHJvdywgcm93SW5kZXgsIGNvbHVtbkluZGV4KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWRpdG9yQ2xhc3MgPSBjcyh7XG4gICAgICAgIGFuaW1hdGVkOiBoYXNFcnJvcixcbiAgICAgICAgc2hha2U6IGhhc0Vycm9yXG4gICAgICB9LCBjdXN0b21FZGl0b3JDbGFzcyk7XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDx0ZFxuICAgICAgICAgIGNsYXNzTmFtZT17IGNzKCdyZWFjdC1ib290c3RyYXAtdGFibGUtZWRpdGluZy1jZWxsJywgY2xhc3NOYW1lKSB9XG4gICAgICAgICAgc3R5bGU9eyBzdHlsZSB9XG4gICAgICAgICAgb25DbGljaz17IHRoaXMuaGFuZGxlQ2xpY2sgfVxuICAgICAgICA+XG4gICAgICAgICAgPFRleHRFZGl0b3JcbiAgICAgICAgICAgIHJlZj17IG5vZGUgPT4gdGhpcy5lZGl0b3IgPSBub2RlIH1cbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT17IHZhbHVlIH1cbiAgICAgICAgICAgIHN0eWxlPXsgZWRpdG9yU3R5bGUgfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXsgZWRpdG9yQ2xhc3MgfVxuICAgICAgICAgICAgeyAuLi5lZGl0b3JBdHRycyB9XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7IGhhc0Vycm9yID8gPEVkaXRvckluZGljYXRvciBpbnZhbGlkTWVzc2FnZT17IGludmFsaWRNZXNzYWdlIH0gLz4gOiBudWxsIH1cbiAgICAgICAgPC90ZD5cbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcGFja2FnZXMvcmVhY3QtYm9vdHN0cmFwLXRhYmxlMi1lZGl0b3Ivc3JjL2VkaXRpbmctY2VsbC5qcyIsIi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY2xhc3MgVGV4dEVkaXRvciBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZGVmYXVsdFZhbHVlIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMudGV4dC52YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICB0aGlzLnRleHQuZm9jdXMoKTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGRlZmF1bHRWYWx1ZSwgY2xhc3NOYW1lLCAuLi5yZXN0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGVkaXRvckNsYXNzID0gY3MoJ2Zvcm0tY29udHJvbCBlZGl0b3IgZWRpdC10ZXh0JywgY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGlucHV0XG4gICAgICAgIHJlZj17IG5vZGUgPT4gdGhpcy50ZXh0ID0gbm9kZSB9XG4gICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgY2xhc3NOYW1lPXsgZWRpdG9yQ2xhc3MgfVxuICAgICAgICB7IC4uLnJlc3QgfVxuICAgICAgLz5cbiAgICApO1xuICB9XG59XG5cblRleHRFZGl0b3IucHJvcFR5cGVzID0ge1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgIFByb3BUeXBlcy5zdHJpbmcsXG4gICAgUHJvcFR5cGVzLm9iamVjdFxuICBdKSxcbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIFByb3BUeXBlcy5udW1iZXJcbiAgXSlcbn07XG5UZXh0RWRpdG9yLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lOiBudWxsLFxuICBkZWZhdWx0VmFsdWU6ICcnXG59O1xuZXhwb3J0IGRlZmF1bHQgVGV4dEVkaXRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy90ZXh0LWVkaXRvci5qcyIsIi8qIGVzbGludCBuby1yZXR1cm4tYXNzaWduOiAwICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuY29uc3QgRWRpdG9ySW5kaWNhdG9yID0gKHsgaW52YWxpZE1lc3NhZ2UgfSkgPT5cbiAgKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYWxlcnQgYWxlcnQtZGFuZ2VyIGZhZGUgaW5cIj5cbiAgICAgIDxzdHJvbmc+eyBpbnZhbGlkTWVzc2FnZSB9PC9zdHJvbmc+XG4gICAgPC9kaXY+XG4gICk7XG5cbkVkaXRvckluZGljYXRvci5wcm9wVHlwZXMgPSB7XG4gIGludmFsaWRNZXNzYWdlOiBQcm9wVHlwZXMuc3RyaW5nXG59O1xuXG5FZGl0b3JJbmRpY2F0b3IuZGVmYXVsdFByb3BzID0ge1xuICBpbnZhbGlkTWVzc2FnZTogbnVsbFxufTtcbmV4cG9ydCBkZWZhdWx0IEVkaXRvckluZGljYXRvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3BhY2thZ2VzL3JlYWN0LWJvb3RzdHJhcC10YWJsZTItZWRpdG9yL3NyYy9lZGl0b3ItaW5kaWNhdG9yLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA0IDUgNiA3IDggOSIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgNCA1IDYgNyA4IDkiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSA0IDUgNiA3IDggOSIsIi8qIVxuICBDb3B5cmlnaHQgKGMpIDIwMTYgSmVkIFdhdHNvbi5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCBzZWVcbiAgaHR0cDovL2plZHdhdHNvbi5naXRodWIuaW8vY2xhc3NuYW1lc1xuKi9cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBoYXNPd24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRmdW5jdGlvbiBjbGFzc05hbWVzICgpIHtcblx0XHR2YXIgY2xhc3NlcyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRpZiAoIWFyZykgY29udGludWU7XG5cblx0XHRcdHZhciBhcmdUeXBlID0gdHlwZW9mIGFyZztcblxuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnIHx8IGFyZ1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChhcmcpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGNsYXNzTmFtZXMuYXBwbHkobnVsbCwgYXJnKSk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRpZiAoaGFzT3duLmNhbGwoYXJnLCBrZXkpICYmIGFyZ1trZXldKSB7XG5cdFx0XHRcdFx0XHRjbGFzc2VzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuXHRcdC8vIHJlZ2lzdGVyIGFzICdjbGFzc25hbWVzJywgY29uc2lzdGVudCB3aXRoIG5wbSBwYWNrYWdlIG5hbWVcblx0XHRkZWZpbmUoJ2NsYXNzbmFtZXMnLCBbXSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGNsYXNzTmFtZXM7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDQgNSA4IDkiXSwic291cmNlUm9vdCI6IiJ9
//# sourceMappingURL=react-bootstrap-table2-editor.js.map